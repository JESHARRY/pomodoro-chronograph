<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pomodoro Chronograph</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: radial-gradient(circle at 20% 20%, #2d2f39, #111219 45%, #0b0c11 80%);
      --accent: #d7b46a;
      --accent-strong: #f4d27a;
      --text: #f5f5f7;
      --muted: #9aa1b1;
      --danger: #ff6b6b;
      --surface: #1a1c24cc;
      --glass: rgba(255, 255, 255, 0.05);
      --shadow-strong: 0 20px 50px rgba(0, 0, 0, 0.6);
      --shadow-soft: 0 8px 20px rgba(0, 0, 0, 0.35);
      --bezel: linear-gradient(145deg, #1d1f27, #101219);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      display: grid;
      place-items: center;
      font-family: "Inter", "SF Pro Display", system-ui, -apple-system, sans-serif;
      color: var(--text);
      overflow: hidden;
    }

    .app {
      width: min(420px, 92vw);
      display: grid;
      gap: 20px;
      justify-items: center;
    }

    .title {
      letter-spacing: 0.2em;
      font-weight: 600;
      text-transform: uppercase;
      color: var(--muted);
      font-size: 13px;
    }

    .watch {
      width: 100%;
      aspect-ratio: 1;
      border-radius: 50%;
      position: relative;
      background: var(--bezel);
      padding: 18px;
      box-shadow:
        inset 0 2px 10px rgba(255, 255, 255, 0.08),
        inset 0 -6px 12px rgba(0, 0, 0, 0.55),
        var(--shadow-strong);
    }

    .dial {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.08), transparent 35%),
        radial-gradient(circle at 70% 70%, rgba(255,255,255,0.04), transparent 40%),
        linear-gradient(120deg, rgba(255,255,255,0.06), rgba(0,0,0,0.35));
      overflow: hidden;
      box-shadow:
        inset 0 0 0 2px rgba(255, 255, 255, 0.05),
        inset 0 0 25px rgba(0, 0, 0, 0.6);
    }

    .dial::before {
      content: "";
      position: absolute;
      inset: 14px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.08), transparent 55%);
      pointer-events: none;
    }

    .ticks {
      position: absolute;
      inset: 12px;
      border-radius: 50%;
      pointer-events: none;
    }

    .tick {
      position: absolute;
      width: 2px;
      height: 10px;
      background: rgba(255, 255, 255, 0.6);
      left: 50%;
      top: 6px;
      transform-origin: center calc(100% + 145px);
      opacity: 0.6;
      border-radius: 2px;
    }

    .tick.major {
      height: 14px;
      width: 3px;
      opacity: 0.9;
      background: var(--accent-strong);
      box-shadow: 0 0 6px rgba(244, 210, 122, 0.6);
    }

    .progress-ring {
      position: absolute;
      inset: 8px;
      border-radius: 50%;
      background:
        conic-gradient(
          from -90deg,
          var(--accent-strong) 0deg,
          var(--accent-strong) 0deg,
          rgba(255,255,255,0.12) 0deg
        );
      mask: radial-gradient(circle at center, transparent 64%, black 65%);
      transition: filter 0.4s ease;
      filter: drop-shadow(0 0 12px rgba(244, 210, 122, 0.3));
    }

    .hands {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
    }

    .hand {
      position: absolute;
      width: 4px;
      height: 44%;
      background: linear-gradient(180deg, var(--accent-strong), #c99c45);
      transform-origin: 50% 88%;
      border-radius: 999px;
      box-shadow: 0 10px 20px rgba(0,0,0,0.35);
      transition: transform 0.12s cubic-bezier(.4,.1,.2,1);
    }

    .hand.second {
      width: 2px;
      height: 48%;
      background: linear-gradient(180deg, #ff7b54, #f24d2d);
      filter: drop-shadow(0 0 6px rgba(255,123,84,0.7));
      transition: transform 0.06s linear;
    }

    .hand::after {
      content: "";
      position: absolute;
      bottom: -14px;
      left: 50%;
      transform: translateX(-50%);
      width: 10px;
      height: 10px;
      background: var(--accent-strong);
      border-radius: 50%;
      box-shadow:
        inset 0 1px 2px rgba(255, 255, 255, 0.4),
        0 4px 10px rgba(0, 0, 0, 0.45);
    }

    .hand.second::after {
      background: #ff7b54;
    }

    .center-cap {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, #e3c27c 30%, #b78d3b 60%, #1a1c24 100%);
      box-shadow:
        inset 0 1px 2px rgba(255, 255, 255, 0.6),
        0 4px 10px rgba(0, 0, 0, 0.4);
    }

    .digital {
      position: absolute;
      inset: 24% 22%;
      display: grid;
      place-items: center;
      font-variant-numeric: tabular-nums;
      font-size: clamp(32px, 7vw, 46px);
      letter-spacing: 0.12em;
      color: var(--text);
      text-shadow: 0 3px 14px rgba(0, 0, 0, 0.65);
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      box-shadow:
        inset 0 0 0 1px rgba(255,255,255,0.04),
        inset 0 12px 30px rgba(255,255,255,0.06),
        0 12px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(4px);
    }

    .status {
      margin-top: 2px;
      font-size: 12px;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
      width: 100%;
    }

    .btn {
      position: relative;
      border: none;
      color: var(--text);
      font-weight: 600;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 14px 12px;
      border-radius: 14px;
      cursor: pointer;
      background: linear-gradient(135deg, #1f2028, #0f1016);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.08),
        0 12px 24px rgba(0,0,0,0.45),
        0 1px 0 rgba(255,255,255,0.06);
      transition: transform 150ms ease, box-shadow 150ms ease, filter 200ms ease, background 200ms ease;
      outline: none;
    }

    .btn:focus-visible {
      box-shadow:
        0 0 0 2px rgba(244, 210, 122, 0.4),
        0 12px 24px rgba(0,0,0,0.45);
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.12),
        0 16px 30px rgba(0,0,0,0.55);
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow:
        inset 0 1px 0 rgba(255,255,255,0.12),
        inset 0 -3px 8px rgba(0,0,0,0.45),
        0 8px 18px rgba(0,0,0,0.4);
    }

    .btn.accent {
      background: linear-gradient(135deg, #e7c57a, #c89a42);
      color: #0d0d11;
    }

    .btn.soft {
      color: var(--muted);
      background: linear-gradient(135deg, #191b22, #0f1016);
    }

    .durations {
      display: flex;
      gap: 8px;
      width: 100%;
      justify-content: center;
    }

    .chip {
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
      color: var(--muted);
      cursor: pointer;
      background: rgba(0,0,0,0.2);
      backdrop-filter: blur(4px);
      transition: border 150ms ease, color 150ms ease, box-shadow 150ms ease;
      font-weight: 600;
      letter-spacing: 0.04em;
    }

    .chip.active {
      color: var(--text);
      border-color: rgba(244, 210, 122, 0.8);
      box-shadow: 0 0 0 1px rgba(244, 210, 122, 0.4);
    }

    .footer {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }

    @media (max-width: 480px) {
      .digital { inset: 26% 18%; }
      .controls { grid-template-columns: repeat(3, 1fr); }
    }
  </style>
</head>
<body>
  <main class="app">
    <div class="title" aria-hidden="true">Pomodoro Chronograph</div>
    <section class="watch" aria-label="Pomodoro chronograph">
      <div class="dial" role="img" aria-label="Analog and digital timer display">
        <div class="progress-ring" aria-hidden="true"></div>
        <div class="ticks" aria-hidden="true"></div>
        <div class="hands" aria-hidden="true">
          <div class="hand minute"></div>
          <div class="hand second"></div>
          <div class="center-cap"></div>
        </div>
        <div class="digital" aria-live="polite" aria-atomic="true">15:00</div>
      </div>
      <div class="status" id="statusText">Idle</div>
    </section>

    <div class="durations" role="group" aria-label="Choose duration">
      <button class="chip active" data-minutes="15">15 min</button>
      <button class="chip" data-minutes="25">25 min</button>
      <button class="chip" data-minutes="45">45 min</button>
    </div>

    <div class="controls" role="group" aria-label="Timer controls">
      <button class="btn accent" id="startBtn">Start</button>
      <button class="btn" id="pauseBtn" hidden>Pause</button>
      <button class="btn soft" id="resetBtn">Reset</button>
    </div>

    <div class="footer" aria-hidden="true">Focus • Breathe • Craft</div>
  </main>

  <script>
    (() => {
      // Single source of truth for elapsed time and state
      const State = Object.freeze({ idle: "idle", running: "running", paused: "paused", completed: "completed" });

      class PomodoroTimer {
        constructor({ onTick, onStateChange }) {
          this.state = State.idle;
          this.duration = 15 * 60 * 1000; // default 15 minutes
          this.elapsed = 0;
          this.intervalId = null;
          this.onTick = onTick;
          this.onStateChange = onStateChange;
        }

        setDuration(minutes) {
          const wasRunning = this.state === State.running;
          this.stopInterval();
          this.duration = minutes * 60 * 1000;
          this.elapsed = 0;
          this.state = State.idle;
          this.onStateChange(this.state);
          this.onTick(this.getSnapshot());
          if (wasRunning) this.start(); // preserves intent if user switches mid-run
        }

        start() {
          if (this.state === State.running) return;
          if (this.state === State.completed) this.elapsed = 0;
          this.state = State.running;
          this.onStateChange(this.state);
          const startTime = performance.now() - this.elapsed;
          this.stopInterval();
          this.intervalId = setInterval(() => {
            const now = performance.now();
            this.elapsed = Math.min(now - startTime, this.duration);
            this.onTick(this.getSnapshot());
            if (this.elapsed >= this.duration) {
              this.complete();
            }
          }, 1000);
          this.onTick(this.getSnapshot());
        }

        pause() {
          if (this.state !== State.running) return;
          this.stopInterval();
          this.state = State.paused;
          this.onStateChange(this.state);
          this.onTick(this.getSnapshot());
        }

        reset() {
          this.stopInterval();
          this.elapsed = 0;
          this.state = State.idle;
          this.onStateChange(this.state);
          this.onTick(this.getSnapshot());
        }

        complete() {
          this.stopInterval();
          this.state = State.completed;
          this.elapsed = this.duration;
          this.onStateChange(this.state);
          this.onTick(this.getSnapshot());
          playChime();
        }

        stopInterval() {
          if (this.intervalId) clearInterval(this.intervalId);
          this.intervalId = null;
        }

        getSnapshot() {
          return {
            state: this.state,
            elapsedMs: this.elapsed,
            remainingMs: Math.max(this.duration - this.elapsed, 0),
            progress: Math.min(this.elapsed / this.duration, 1)
          };
        }
      }

      // DOM references
      const digitalEl = document.querySelector(".digital");
      const statusEl = document.getElementById("statusText");
      const progressRing = document.querySelector(".progress-ring");
      const handMinute = document.querySelector(".hand.minute");
      const handSecond = document.querySelector(".hand.second");
      const startBtn = document.getElementById("startBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const resetBtn = document.getElementById("resetBtn");
      const chips = Array.from(document.querySelectorAll(".chip"));
      const ticksContainer = document.querySelector(".ticks");

      // Render minute ticks for realism
      (() => {
        const totalTicks = 60;
        const radiusAdjust = 0; // slight room to tweak spacing if desired
        for (let i = 0; i < totalTicks; i++) {
          const tick = document.createElement("div");
          tick.className = "tick" + (i % 5 === 0 ? " major" : "");
          const angle = i * 6; // 360 / 60
          tick.style.transform = `translate(-50%, 0) rotate(${angle}deg) translateY(${radiusAdjust}px)`;
          ticksContainer.appendChild(tick);
        }
      })();

      const timer = new PomodoroTimer({
        onTick: render,
        onStateChange: syncControls
      });

      startBtn.addEventListener("click", () => timer.start());
      pauseBtn.addEventListener("click", () => timer.pause());
      resetBtn.addEventListener("click", () => timer.reset());

      chips.forEach(chip => {
        chip.addEventListener("click", () => {
          chips.forEach(c => c.classList.remove("active"));
          chip.classList.add("active");
          timer.setDuration(Number(chip.dataset.minutes));
        });
      });

      // Accessibility: keyboard shortcuts for primary actions
      window.addEventListener("keydown", (e) => {
        if (e.key === " " || e.key === "Enter") {
          if (document.activeElement === startBtn) { timer.start(); e.preventDefault(); }
          if (document.activeElement === pauseBtn) { timer.pause(); e.preventDefault(); }
          if (document.activeElement === resetBtn) { timer.reset(); e.preventDefault(); }
        }
      });

      function formatTime(ms) {
        const totalSeconds = Math.ceil(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
      }

      function render(snapshot) {
        const { remainingMs, progress } = snapshot;
        digitalEl.textContent = formatTime(remainingMs);

        // Progress ring
        const deg = progress * 360;
        progressRing.style.background = `conic-gradient(from -90deg, var(--accent-strong) ${deg}deg, rgba(255,255,255,0.12) ${deg}deg)`;
        progressRing.style.filter = snapshot.state === State.running
          ? "drop-shadow(0 0 18px rgba(244,210,122,0.45))"
          : "drop-shadow(0 0 12px rgba(244,210,122,0.25))";

        // Analog hands (single time source)
        const totalSeconds = (timer.duration - remainingMs) / 1000;
        const minuteAngle = (totalSeconds / 60) * 6; // 360/60
        const secondAngle = (totalSeconds % 60) * 6;

        handMinute.style.transform = `rotate(${minuteAngle}deg)`;
        handSecond.style.transform = `rotate(${secondAngle}deg)`;
      }

      function syncControls(state) {
        statusEl.textContent = state.charAt(0).toUpperCase() + state.slice(1);
        switch (state) {
          case State.idle:
            startBtn.hidden = false;
            pauseBtn.hidden = true;
            startBtn.textContent = "Start";
            break;
          case State.running:
            startBtn.hidden = true;
            pauseBtn.hidden = false;
            break;
          case State.paused:
            startBtn.hidden = false;
            pauseBtn.hidden = true;
            startBtn.textContent = "Resume";
            break;
          case State.completed:
            startBtn.hidden = false;
            pauseBtn.hidden = true;
            startBtn.textContent = "Restart";
            break;
        }
      }

      // Soft completion chime without external assets
      function playChime() {
        try {
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = "sine";
          o.frequency.value = 880;
          g.gain.setValueAtTime(0.001, ctx.currentTime);
          g.gain.exponentialRampToValueAtTime(0.08, ctx.currentTime + 0.05);
          g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 1.2);
          o.connect(g).connect(ctx.destination);
          o.start();
          o.stop(ctx.currentTime + 1.25);
        } catch {
          // Silent failure; audio is optional
        }
      }

      // Initial render
      render(timer.getSnapshot());
      syncControls(timer.state);
    })();
  </script>
</body>
</html>
